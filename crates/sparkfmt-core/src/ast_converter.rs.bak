//! AST Converter
//!
//! Converts ANTLR parse tree (Concrete Syntax Tree) to our formatting IR.
//! MUST handle ALL grammar rules - no silent drops.
//!
//! This module is part of the grammar-driven parser refactor. Once complete,
//! it will be the authoritative converter from ANTLR CST to our IR types.
//!
//! # Design Principles
//!
//! 1. **NO SILENT DROPS**: Every unhandled case MUST return an error
//! 2. Direct tree traversal using context methods (simpler than visitor pattern)
//! 3. Start with basic SELECT queries, expand incrementally
//! 4. Use `Result<T, FormatError>` for all conversion functions

use std::rc::Rc;
use antlr4rust::tree::ParseTree;
use antlr4rust::token::Token;

use crate::error::FormatError;
use crate::ir::*;
use crate::generated::sqlbaseparser::*;

// ============================================================================
// Main Entry Point
// ============================================================================

/// Convert ANTLR parse tree to IR Statement.
///
/// MUST handle every node type from the grammar.
/// MUST return error for unhandled nodes (NEVER silent drop).
pub fn convert(tree: &SingleStatementContextAll) -> Result<Statement, FormatError> {
    // SingleStatement contains either a statement() or setResetStatement()
    if let Some(stmt) = tree.statement() {
        convert_statement(&stmt)
    } else if tree.setResetStatement().is_some() {
        Err(FormatError::new(
            "SET/RESET statements not yet supported in AST converter".to_string()
        ))
    } else {
        Err(FormatError::new(
            "No statement found in parse tree".to_string()
        ))
    }
}

// ============================================================================
// Statement Conversion
// ============================================================================

/// Convert a StatementContext to our IR Statement.
fn convert_statement(ctx: &StatementContextAll) -> Result<Statement, FormatError> {
    // StatementContext has many variants - we check for the ones we support
    // Most common is a query (SELECT statement)
    match ctx {
        StatementContextAll::StatementDefaultContext(stmt_ctx) => {
            // statementDefault contains a query
            if let Some(query) = stmt_ctx.query() {
                convert_query(&query)
            } else {
                Err(FormatError::new(
                    "StatementDefault without query not supported".to_string()
                ))
            }
        }
        // Add other statement types as needed
        other => {
            // Get a description of what type this is for error reporting
            let type_name = format!("{:?}", other);
            // Truncate for readability
            let type_name = if type_name.len() > 50 {
                format!("{}...", &type_name[..50])
            } else {
                type_name
            };
            Err(FormatError::new(format!(
                "Unsupported statement type: {}",
                type_name
            )))
        }
    }
}

// ============================================================================
// Query Conversion
// ============================================================================

/// Convert a QueryContext to our IR Statement.
/// Query has: ctes (WITH), queryTerm (the SELECT), queryOrganization (ORDER BY, LIMIT)
fn convert_query(ctx: &QueryContextAll) -> Result<Statement, FormatError> {
    // Get the query term (contains the SELECT)
    let query_term = ctx.queryTerm().ok_or_else(|| {
        FormatError::new("Missing query term in query".to_string())
    })?;
    
    // Convert the query term to a base statement
    let mut statement = convert_query_term(&query_term)?;
    
    // Apply query organization (ORDER BY, LIMIT, etc.)
    if let Some(org) = ctx.queryOrganization() {
        apply_query_organization(&mut statement, &org)?;
    }
    
    // Handle CTEs (WITH clause)
    if let Some(ctes_ctx) = ctx.ctes() {
        apply_ctes(&mut statement, &ctes_ctx)?;
    }
    
    Ok(statement)
}

/// Convert QueryTermContext - can be a simple query or set operation (UNION, etc.)
fn convert_query_term(ctx: &QueryTermContextAll) -> Result<Statement, FormatError> {
    match ctx {
        QueryTermContextAll::QueryTermDefaultContext(default_ctx) => {
            // Simple query - get the queryPrimary
            if let Some(primary) = default_ctx.queryPrimary() {
                convert_query_primary(&primary)
            } else {
                Err(FormatError::new(
                    "QueryTermDefault missing queryPrimary".to_string()
                ))
            }
        }
        QueryTermContextAll::SetOperationContext(set_op_ctx) => {
            // UNION, EXCEPT, INTERSECT, MINUS
            convert_set_operation(set_op_ctx)
        }
        QueryTermContextAll::OperatorPipeStatementContext(_) => {
            Err(FormatError::new(
                "Operator pipe statements not yet supported".to_string()
            ))
        }
        QueryTermContextAll::Error(_) => {
            Err(FormatError::new(
                "Error in query term parse tree".to_string()
            ))
        }
    }
}

/// Convert QueryPrimaryContext - the actual SELECT or subquery
fn convert_query_primary(ctx: &QueryPrimaryContextAll) -> Result<Statement, FormatError> {
    match ctx {
        QueryPrimaryContextAll::QueryPrimaryDefaultContext(default_ctx) => {
            // This contains a querySpecification (the actual SELECT)
            if let Some(spec) = default_ctx.querySpecification() {
                convert_query_specification(&spec)
            } else {
                Err(FormatError::new(
                    "QueryPrimaryDefault missing querySpecification".to_string()
                ))
            }
        }
        QueryPrimaryContextAll::SubqueryContext(subquery_ctx) => {
            // Parenthesized subquery: (SELECT ...)
            if let Some(query) = subquery_ctx.query() {
                convert_query(&query)
            } else {
                Err(FormatError::new(
                    "Subquery missing inner query".to_string()
                ))
            }
        }
        QueryPrimaryContextAll::TableContext(_) => {
            Err(FormatError::new(
                "TABLE statement not yet supported".to_string()
            ))
        }
        QueryPrimaryContextAll::InlineTableDefault1Context(_) => {
            Err(FormatError::new(
                "Inline table (VALUES) not yet supported".to_string()
            ))
        }
        QueryPrimaryContextAll::FromStmtContext(_) => {
            Err(FormatError::new(
                "FROM-first statements not yet supported".to_string()
            ))
        }
        QueryPrimaryContextAll::Error(_) => {
            Err(FormatError::new(
                "Error in query primary parse tree".to_string()
            ))
        }
    }
}

/// Convert QuerySpecificationContext - the SELECT ... FROM ... WHERE ...
fn convert_query_specification(ctx: &QuerySpecificationContextAll) -> Result<Statement, FormatError> {
    match ctx {
        QuerySpecificationContextAll::RegularQuerySpecificationContext(reg_ctx) => {
            convert_regular_query_spec(reg_ctx)
        }
        QuerySpecificationContextAll::TransformQuerySpecificationContext(_) => {
            Err(FormatError::new(
                "TRANSFORM queries not yet supported".to_string()
            ))
        }
        QuerySpecificationContextAll::Error(_) => {
            Err(FormatError::new(
                "Error in query specification parse tree".to_string()
            ))
        }
    }
}

/// Convert a regular SELECT query specification
fn convert_regular_query_spec(ctx: &RegularQuerySpecificationContext) -> Result<Statement, FormatError> {
    // Get the SELECT clause (required)
    let select_clause = ctx.selectClause().ok_or_else(|| {
        FormatError::new("Missing SELECT clause".to_string())
    })?;
    
    // Convert SELECT list
    let (select_list, distinct, hint_comment) = convert_select_clause(&select_clause)?;
    
    // Convert FROM clause (optional)
    let from = if let Some(from_ctx) = ctx.fromClause() {
        Some(convert_from_clause(&from_ctx)?)
    } else {
        None
    };
    
    // Convert WHERE clause (optional)
    let where_clause = if let Some(where_ctx) = ctx.whereClause() {
        Some(convert_where_clause(&where_ctx)?)
    } else {
        None
    };
    
    // Convert GROUP BY clause (optional) - called aggregationClause in grammar
    let group_by = if let Some(agg_ctx) = ctx.aggregationClause() {
        Some(convert_aggregation_clause(&agg_ctx)?)
    } else {
        None
    };
    
    // Convert HAVING clause (optional)
    let having = if let Some(having_ctx) = ctx.havingClause() {
        Some(convert_having_clause(&having_ctx)?)
    } else {
        None
    };
    
    Ok(Statement::Select(SelectQuery {
        with_clause: None, // Set by apply_ctes
        distinct,
        select_list,
        from,
        where_clause,
        group_by,
        having,
        order_by: None, // Set by apply_query_organization
        cluster_by: None,
        distribute_by: None,
        sort_by: None,
        limit: None,
        leading_comments: Vec::new(),
        hint_comment,
        fallback_comments: Vec::new(),
    }))
}

// ============================================================================
// SELECT Clause Conversion
// ============================================================================

/// Convert SelectClauseContext to select list items
/// Returns (select_list, is_distinct, hint_comment)
fn convert_select_clause(ctx: &SelectClauseContext) -> Result<(Vec<SelectItem>, bool, Option<String>), FormatError> {
    // Check for DISTINCT
    let distinct = ctx.setQuantifier()
        .map(|sq| sq.DISTINCT().is_some())
        .unwrap_or(false);
    
    // Extract hint comments
    let hint_comment = if !ctx.hint_all().is_empty() {
        // Combine all hints into one string
        let hints: Vec<String> = ctx.hint_all()
            .iter()
            .filter_map(|h| {
                // Get the full text of the hint context
                let text = h.get_text();
                if !text.is_empty() {
                    Some(text)
                } else {
                    None
                }
            })
            .collect();
        if hints.is_empty() {
            None
        } else {
            Some(hints.join(" "))
        }
    } else {
        None
    };
    
    // Get namedExpressionSeq - this contains the SELECT list
    // The selectClause calls namedExpressionSeq internally
    // We need to access the children to find it
    let mut select_list = Vec::new();
    
    // Try to find namedExpressionSeq by iterating children
    for i in 0..ctx.get_child_count() {
        if let Some(child) = ctx.get_child(i) {
            // Check if this child has named expressions
            // The structure is: SELECT [hints] [DISTINCT] namedExpressionSeq
            if let Some(named_expr_seq) = child.downcast_ref::<NamedExpressionSeqContext>() {
                select_list = convert_named_expression_seq(named_expr_seq)?;
                break;
            }
        }
    }
    
    // If we didn't find it via downcasting, try to parse from the raw text
    // This is a fallback - ideally we should always get it via the proper methods
    if select_list.is_empty() {
        // Fallback: parse the full select clause text
        let full_text = ctx.get_text();
        // Remove SELECT keyword and any DISTINCT
        let items_text = full_text
            .strip_prefix("SELECT")
            .or_else(|| full_text.strip_prefix("select"))
            .unwrap_or(&full_text)
            .trim();
        let items_text = items_text
            .strip_prefix("DISTINCT")
            .or_else(|| items_text.strip_prefix("distinct"))
            .unwrap_or(items_text)
            .trim();
        
        // Simple split on comma (won't work for complex expressions, but handles basic cases)
        if !items_text.is_empty() {
            for item in items_text.split(',') {
                let item = item.trim();
                if !item.is_empty() {
                    select_list.push(SelectItem {
                        expr: Expression::Identifier(item.to_string()),
                        alias: None,
                        trailing_comment: None,
                    });
                }
            }
        }
    }
    
    Ok((select_list, distinct, hint_comment))
}

/// Convert NamedExpressionSeqContext to a list of SelectItems
fn convert_named_expression_seq(ctx: &NamedExpressionSeqContext) -> Result<Vec<SelectItem>, FormatError> {
    let mut items = Vec::new();
    
    for named_expr in ctx.namedExpression_all() {
        items.push(convert_named_expression(&named_expr)?);
    }
    
    Ok(items)
}

/// Convert a NamedExpressionContext to a SelectItem
fn convert_named_expression(ctx: &NamedExpressionContext) -> Result<SelectItem, FormatError> {
    // Get the expression
    let expr = if let Some(expr_ctx) = ctx.expression() {
        convert_expression(&expr_ctx)?
    } else {
        return Err(FormatError::new(
            "NamedExpression missing expression".to_string()
        ));
    };
    
    // Get the alias if present
    let alias = if let Some(name_ctx) = &ctx.name {
        // errorCapturingIdentifier -> identifier
        Some(name_ctx.get_text())
    } else if ctx.AS().is_some() {
        // There's an AS but we need to get what follows
        // Try getting the identifier list
        if let Some(id_list) = ctx.identifierList() {
            Some(id_list.get_text())
        } else {
            None
        }
    } else {
        None
    };
    
    Ok(SelectItem {
        expr,
        alias,
        trailing_comment: None,
    })
}

// ============================================================================
// Expression Conversion
// ============================================================================

/// Convert an ExpressionContext to our IR Expression
fn convert_expression(ctx: &ExpressionContextAll) -> Result<Expression, FormatError> {
    // Expression -> booleanExpression
    if let Some(bool_expr) = ctx.booleanExpression() {
        convert_boolean_expression(&bool_expr)
    } else {
        // Fallback: use raw text
        Ok(Expression::Identifier(ctx.get_text()))
    }
}

/// Convert BooleanExpressionContext
fn convert_boolean_expression(ctx: &BooleanExpressionContextAll) -> Result<Expression, FormatError> {
    match ctx {
        BooleanExpressionContextAll::LogicalNotContext(not_ctx) => {
            // NOT expression
            if let Some(inner) = not_ctx.booleanExpression() {
                Ok(Expression::UnaryOp {
                    op: "NOT".to_string(),
                    expr: Box::new(convert_boolean_expression(&inner)?),
                })
            } else {
                Err(FormatError::new("NOT without expression".to_string()))
            }
        }
        BooleanExpressionContextAll::PredicatedContext(pred_ctx) => {
            // This wraps valueExpression with optional predicate
            if let Some(val_expr) = pred_ctx.valueExpression() {
                let base_expr = convert_value_expression(&val_expr)?;
                
                // Check for predicate (IS NULL, LIKE, IN, BETWEEN, etc.)
                if let Some(pred) = pred_ctx.predicate() {
                    apply_predicate(base_expr, &pred)
                } else {
                    Ok(base_expr)
                }
            } else {
                Err(FormatError::new("Predicated without valueExpression".to_string()))
            }
        }
        BooleanExpressionContextAll::LogicalBinaryContext(bin_ctx) => {
            // AND, OR
            let left = bin_ctx.booleanExpression(0).ok_or_else(|| {
                FormatError::new("LogicalBinary missing left expression".to_string())
            })?;
            let right = bin_ctx.booleanExpression(1).ok_or_else(|| {
                FormatError::new("LogicalBinary missing right expression".to_string())
            })?;
            
            let op = if bin_ctx.AND().is_some() {
                "AND"
            } else if bin_ctx.OR().is_some() {
                "OR"
            } else {
                return Err(FormatError::new("Unknown logical operator".to_string()));
            };
            
            Ok(Expression::BinaryOp {
                left: Box::new(convert_boolean_expression(&left)?),
                op: op.to_string(),
                right: Box::new(convert_boolean_expression(&right)?),
            })
        }
        BooleanExpressionContextAll::ExistsContext(exists_ctx) => {
            if let Some(query) = exists_ctx.query() {
                let subquery = convert_query(&query)?;
                Ok(Expression::Exists {
                    subquery: Box::new(subquery),
                    negated: false,
                })
            } else {
                Err(FormatError::new("EXISTS without query".to_string()))
            }
        }
        BooleanExpressionContextAll::Error(_) => {
            Err(FormatError::new("Error in boolean expression parse tree".to_string()))
        }
    }
}

/// Convert ValueExpressionContext
fn convert_value_expression(ctx: &ValueExpressionContextAll) -> Result<Expression, FormatError> {
    match ctx {
        ValueExpressionContextAll::ValueExpressionDefaultContext(default_ctx) => {
            if let Some(primary) = default_ctx.primaryExpression() {
                convert_primary_expression(&primary)
            } else {
                Err(FormatError::new("ValueExpressionDefault missing primaryExpression".to_string()))
            }
        }
        ValueExpressionContextAll::ArithmeticBinaryContext(arith_ctx) => {
            let left = arith_ctx.valueExpression(0).ok_or_else(|| {
                FormatError::new("ArithmeticBinary missing left".to_string())
            })?;
            let right = arith_ctx.valueExpression(1).ok_or_else(|| {
                FormatError::new("ArithmeticBinary missing right".to_string())
            })?;
            
            // Determine the operator
            let op = if arith_ctx.PLUS().is_some() { "+" }
                else if arith_ctx.MINUS().is_some() { "-" }
                else if arith_ctx.ASTERISK().is_some() { "*" }
                else if arith_ctx.SLASH().is_some() { "/" }
                else if arith_ctx.PERCENT().is_some() { "%" }
                else if arith_ctx.DIV().is_some() { "DIV" }
                else if arith_ctx.AMPERSAND().is_some() { "&" }
                else if arith_ctx.PIPE().is_some() { "|" }
                else if arith_ctx.HAT().is_some() { "^" }
                else { "?" };
            
            Ok(Expression::BinaryOp {
                left: Box::new(convert_value_expression(&left)?),
                op: op.to_string(),
                right: Box::new(convert_value_expression(&right)?),
            })
        }
        ValueExpressionContextAll::ArithmeticUnaryContext(unary_ctx) => {
            if let Some(inner) = unary_ctx.valueExpression() {
                let op = if unary_ctx.MINUS().is_some() { "-" }
                    else if unary_ctx.PLUS().is_some() { "+" }
                    else if unary_ctx.TILDE().is_some() { "~" }
                    else { "?" };
                
                Ok(Expression::UnaryOp {
                    op: op.to_string(),
                    expr: Box::new(convert_value_expression(&inner)?),
                })
            } else {
                Err(FormatError::new("ArithmeticUnary missing expression".to_string()))
            }
        }
        ValueExpressionContextAll::ComparisonContext(cmp_ctx) => {
            let left = cmp_ctx.valueExpression(0).ok_or_else(|| {
                FormatError::new("Comparison missing left".to_string())
            })?;
            let right = cmp_ctx.valueExpression(1).ok_or_else(|| {
                FormatError::new("Comparison missing right".to_string())
            })?;
            
            // Get the comparison operator
            let op = if let Some(cmp_op) = cmp_ctx.comparisonOperator() {
                cmp_op.get_text()
            } else {
                "=".to_string()
            };
            
            Ok(Expression::BinaryOp {
                left: Box::new(convert_value_expression(&left)?),
                op,
                right: Box::new(convert_value_expression(&right)?),
            })
        }
        ValueExpressionContextAll::ShiftExpressionContext(shift_ctx) => {
            // Bit shift: << >> >>>
            let left = shift_ctx.valueExpression(0).ok_or_else(|| {
                FormatError::new("ShiftExpression missing left".to_string())
            })?;
            let right = shift_ctx.valueExpression(1).ok_or_else(|| {
                FormatError::new("ShiftExpression missing right".to_string())
            })?;
            
            // Get the shift operator from the context text
            let full_text = shift_ctx.get_text();
            let op = if full_text.contains(">>>") {
                ">>>"
            } else if full_text.contains(">>") {
                ">>"
            } else {
                "<<"
            };
            
            Ok(Expression::BinaryOp {
                left: Box::new(convert_value_expression(&left)?),
                op: op.to_string(),
                right: Box::new(convert_value_expression(&right)?),
            })
        }
        ValueExpressionContextAll::Error(_) => {
            Err(FormatError::new("Error in value expression parse tree".to_string()))
        }
    }
}

/// Convert PrimaryExpressionContext - the basic building blocks
fn convert_primary_expression(ctx: &PrimaryExpressionContextAll) -> Result<Expression, FormatError> {
    match ctx {
        PrimaryExpressionContextAll::ColumnReferenceContext(col_ctx) => {
            // Simple column reference
            if let Some(id) = col_ctx.identifier() {
                Ok(Expression::Identifier(id.get_text()))
            } else {
                Ok(Expression::Identifier(col_ctx.get_text()))
            }
        }
        PrimaryExpressionContextAll::DereferenceContext(deref_ctx) => {
            // qualified.column or column.field
            // Build the full qualified name
            let base = if let Some(base_ctx) = deref_ctx.base.as_ref() {
                convert_primary_expression(base_ctx)?
            } else {
                Expression::Identifier("".to_string())
            };
            
            let field = if let Some(field_id) = deref_ctx.fieldName.as_ref() {
                field_id.get_text()
            } else {
                "".to_string()
            };
            
            // For qualified identifiers, combine into a single identifier
            match base {
                Expression::Identifier(base_name) => {
                    if base_name.is_empty() {
                        Ok(Expression::Identifier(field))
                    } else {
                        Ok(Expression::Identifier(format!("{}.{}", base_name, field)))
                    }
                }
                _ => {
                    // For more complex expressions, use full text
                    Ok(Expression::Identifier(ctx.get_text()))
                }
            }
        }
        PrimaryExpressionContextAll::ConstantDefaultContext(const_ctx) => {
            // Literal value
            if let Some(constant) = const_ctx.constant() {
                convert_constant(&constant)
            } else {
                Ok(Expression::Literal(const_ctx.get_text()))
            }
        }
        PrimaryExpressionContextAll::StarContext(_) => {
            Ok(Expression::Star)
        }
        PrimaryExpressionContextAll::FunctionCallContext(func_ctx) => {
            convert_function_call(func_ctx)
        }
        PrimaryExpressionContextAll::ParenthesizedExpressionContext(paren_ctx) => {
            if let Some(inner) = paren_ctx.expression() {
                Ok(Expression::Parenthesized(Box::new(convert_expression(&inner)?)))
            } else {
                Err(FormatError::new("Parenthesized expression without inner".to_string()))
            }
        }
        PrimaryExpressionContextAll::CastContext(cast_ctx) => {
            if let Some(expr) = cast_ctx.expression() {
                let data_type = cast_ctx.dataType()
                    .map(|dt| dt.get_text())
                    .unwrap_or_else(|| "?".to_string());
                Ok(Expression::Cast {
                    expr: Box::new(convert_expression(&expr)?),
                    data_type,
                    pg_style: false,
                })
            } else {
                Err(FormatError::new("CAST without expression".to_string()))
            }
        }
        PrimaryExpressionContextAll::SearchedCaseContext(case_ctx) => {
            convert_searched_case(case_ctx)
        }
        PrimaryExpressionContextAll::SimpleCaseContext(case_ctx) => {
            convert_simple_case(case_ctx)
        }
        PrimaryExpressionContextAll::SubqueryExpressionContext(subq_ctx) => {
            if let Some(query) = subq_ctx.query() {
                Ok(Expression::Subquery(Box::new(convert_query(&query)?)))
            } else {
                Err(FormatError::new("Subquery without query".to_string()))
            }
        }
        PrimaryExpressionContextAll::CurrentLikeContext(current_ctx) => {
            // CURRENT_DATE, CURRENT_TIMESTAMP, etc.
            Ok(Expression::Identifier(current_ctx.get_text()))
        }
        PrimaryExpressionContextAll::NullLiteralContext(_) => {
            Ok(Expression::Literal("NULL".to_string()))
        }
        // Handle other primary expression types
        _ => {
            // Fallback: use raw text for unhandled types
            // Log the type for debugging but don't fail
            Ok(Expression::Identifier(ctx.get_text()))
        }
    }
}

/// Convert a constant (literal value)
fn convert_constant(ctx: &ConstantContextAll) -> Result<Expression, FormatError> {
    match ctx {
        ConstantContextAll::NullLiteralContext(_) => {
            Ok(Expression::Literal("NULL".to_string()))
        }
        ConstantContextAll::NumericLiteralContext(num_ctx) => {
            if let Some(number) = num_ctx.number() {
                Ok(Expression::Literal(number.get_text()))
            } else {
                Ok(Expression::Literal(num_ctx.get_text()))
            }
        }
        ConstantContextAll::BooleanLiteralContext(bool_ctx) => {
            Ok(Expression::Literal(bool_ctx.get_text()))
        }
        ConstantContextAll::StringLiteralContext(str_ctx) => {
            Ok(Expression::Literal(str_ctx.get_text()))
        }
        ConstantContextAll::TypeConstructorContext(type_ctx) => {
            // DATE '2021-01-01', TIMESTAMP '...', etc.
            let type_name = if type_ctx.DATE().is_some() {
                "DATE"
            } else if type_ctx.TIMESTAMP().is_some() {
                "TIMESTAMP"
            } else if type_ctx.TIMESTAMP_LTZ().is_some() {
                "TIMESTAMP_LTZ"
            } else if type_ctx.TIMESTAMP_NTZ().is_some() {
                "TIMESTAMP_NTZ"
            } else {
                "UNKNOWN"
            };
            
            let value = type_ctx.get_text();
            // Remove the type name prefix to get just the value
            let value_start = value.find('\'').unwrap_or(0);
            let value_text = &value[value_start..];
            
            Ok(Expression::TypedLiteral {
                type_name: type_name.to_string(),
                value: value_text.to_string(),
            })
        }
        ConstantContextAll::IntervalLiteralContext(interval_ctx) => {
            Ok(Expression::TypedLiteral {
                type_name: "INTERVAL".to_string(),
                value: interval_ctx.get_text(),
            })
        }
        _ => {
            // Fallback for other constant types
            Ok(Expression::Literal(ctx.get_text()))
        }
    }
}

/// Convert a function call
fn convert_function_call(ctx: &FunctionCallContext) -> Result<Expression, FormatError> {
    // Get function name
    let name = if let Some(func_name) = ctx.functionName() {
        func_name.get_text()
    } else {
        ctx.get_text()
    };
    
    // Get arguments
    let mut args = Vec::new();
    
    // Check for * argument (COUNT(*))
    if ctx.ASTERISK().is_some() {
        args.push(Expression::Star);
    } else {
        // Get argument list
        for arg in ctx.argument_all() {
            if let Some(expr) = arg.expression() {
                args.push(convert_expression(&expr)?);
            }
        }
    }
    
    Ok(Expression::FunctionCall { name, args })
}

/// Convert searched CASE expression (CASE WHEN ... THEN ... END)
fn convert_searched_case(ctx: &SearchedCaseContext) -> Result<Expression, FormatError> {
    let mut when_clauses = Vec::new();
    
    for when_ctx in ctx.whenClause_all() {
        if let (Some(cond), Some(result)) = (when_ctx.condition.as_ref(), when_ctx.result.as_ref()) {
            when_clauses.push(WhenClause {
                condition: convert_expression(cond)?,
                result: convert_expression(result)?,
            });
        }
    }
    
    let else_clause = if let Some(else_expr) = ctx.elseExpression.as_ref() {
        Some(Box::new(convert_expression(else_expr)?))
    } else {
        None
    };
    
    Ok(Expression::Case {
        operand: None,
        when_clauses,
        else_clause,
    })
}

/// Convert simple CASE expression (CASE expr WHEN ... THEN ... END)
fn convert_simple_case(ctx: &SimpleCaseContext) -> Result<Expression, FormatError> {
    let operand = if let Some(value) = ctx.value.as_ref() {
        Some(Box::new(convert_expression(value)?))
    } else {
        None
    };
    
    let mut when_clauses = Vec::new();
    for when_ctx in ctx.whenClause_all() {
        if let (Some(cond), Some(result)) = (when_ctx.condition.as_ref(), when_ctx.result.as_ref()) {
            when_clauses.push(WhenClause {
                condition: convert_expression(cond)?,
                result: convert_expression(result)?,
            });
        }
    }
    
    let else_clause = if let Some(else_expr) = ctx.elseExpression.as_ref() {
        Some(Box::new(convert_expression(else_expr)?))
    } else {
        None
    };
    
    Ok(Expression::Case {
        operand,
        when_clauses,
        else_clause,
    })
}

/// Apply a predicate to an expression
fn apply_predicate(base: Expression, pred: &PredicateContextAll) -> Result<Expression, FormatError> {
    // Check for various predicate types
    let negated = pred.NOT().is_some();
    
    // IS NULL / IS NOT NULL
    if pred.NULL().is_some() {
        return Ok(Expression::IsNull {
            expr: Box::new(base),
            negated,
        });
    }
    
    // LIKE / RLIKE
    if pred.LIKE().is_some() || pred.ILIKE().is_some() {
        if let Some(pattern) = pred.valueExpression(0) {
            return Ok(Expression::Like {
                expr: Box::new(base),
                pattern: Box::new(convert_value_expression(&pattern)?),
                escape: None,
                negated,
                regex: false,
            });
        }
    }
    
    if pred.RLIKE().is_some() {
        if let Some(pattern) = pred.valueExpression(0) {
            return Ok(Expression::Like {
                expr: Box::new(base),
                pattern: Box::new(convert_value_expression(&pattern)?),
                escape: None,
                negated,
                regex: true,
            });
        }
    }
    
    // BETWEEN
    if pred.BETWEEN().is_some() {
        let low = pred.lower.as_ref().ok_or_else(|| {
            FormatError::new("BETWEEN missing lower bound".to_string())
        })?;
        let high = pred.upper.as_ref().ok_or_else(|| {
            FormatError::new("BETWEEN missing upper bound".to_string())
        })?;
        
        return Ok(Expression::Between {
            expr: Box::new(base),
            low: Box::new(convert_value_expression(low)?),
            high: Box::new(convert_value_expression(high)?),
            negated,
        });
    }
    
    // IN (list)
    if pred.IN().is_some() {
        // Check for subquery
        if let Some(query) = pred.query() {
            return Ok(Expression::InSubquery {
                expr: Box::new(base),
                subquery: Box::new(convert_query(&query)?),
                negated,
            });
        }
        
        // Otherwise it's an IN list
        let mut list = Vec::new();
        for val in pred.expression_all() {
            list.push(convert_expression(&val)?);
        }
        
        return Ok(Expression::InList {
            expr: Box::new(base),
            list,
            negated,
        });
    }
    
    // Default: return the base expression (no predicate applied)
    Ok(base)
}

// ============================================================================
// FROM Clause Conversion
// ============================================================================

/// Convert FromClauseContext
fn convert_from_clause(ctx: &FromClauseContext) -> Result<FromClause, FormatError> {
    let relations = ctx.relation_all();
    
    if relations.is_empty() {
        return Err(FormatError::new("FROM clause has no relations".to_string()));
    }
    
    // Get the first relation as the primary table
    let first_relation = &relations[0];
    let table = convert_relation(first_relation)?;
    
    // Additional relations (comma joins) become implicit cross joins
    // For now, we'll handle just the first relation
    // TODO: Handle multiple comma-separated relations
    
    Ok(FromClause {
        table,
        joins: Vec::new(), // JOINs are handled within the relation
    })
}

/// Convert a RelationContext
fn convert_relation(ctx: &RelationContextAll) -> Result<TableRef, FormatError> {
    match ctx {
        RelationContextAll::JoinRelationContext(join_ctx) => {
            // This has a base relation and optional joins
            if let Some(relation_primary) = join_ctx.relationPrimary() {
                let mut table = convert_relation_primary(&relation_primary)?;
                
                // Handle joins
                for join_rel in join_ctx.joinRelation_all() {
                    // Joins are complex - for now store them separately
                    // TODO: Properly convert joins
                    let _ = join_rel; // Mark as used
                }
                
                Ok(table)
            } else {
                Err(FormatError::new("JoinRelation missing relationPrimary".to_string()))
            }
        }
        RelationContextAll::RelationPrimaryContext(primary_ctx) => {
            if let Some(primary) = primary_ctx.relationPrimary() {
                convert_relation_primary(&primary)
            } else {
                Err(FormatError::new("RelationPrimary context missing relationPrimary".to_string()))
            }
        }
        RelationContextAll::Error(_) => {
            Err(FormatError::new("Error in relation parse tree".to_string()))
        }
    }
}

/// Convert a RelationPrimaryContext (the base table/subquery)
fn convert_relation_primary(ctx: &RelationPrimaryContextAll) -> Result<TableRef, FormatError> {
    match ctx {
        RelationPrimaryContextAll::TableNameContext(table_ctx) => {
            // Get the table identifier
            let table_name = if let Some(table_id) = table_ctx.tableIdentifier() {
                table_id.get_text()
            } else if let Some(multi_id) = table_ctx.multipartIdentifier() {
                multi_id.get_text()
            } else {
                table_ctx.get_text()
            };
            
            // Get alias if present
            let alias = table_ctx.tableAlias().and_then(|alias| {
                // Try to get the identifier for the alias
                if let Some(strict_id) = alias.strictIdentifier() {
                    Some(strict_id.get_text())
                } else {
                    // Check if there's any text after AS
                    let text = alias.get_text();
                    if !text.is_empty() && text != "AS" {
                        Some(text.trim_start_matches("AS").trim().to_string())
                    } else {
                        None
                    }
                }
            });
            
            Ok(TableRef {
                source: TableSource::Table(table_name),
                alias,
                lateral_views: Vec::new(),
                pivot: None,
                unpivot: None,
                tablesample: None,
            })
        }
        RelationPrimaryContextAll::AliasedQueryContext(aq_ctx) => {
            // Subquery with alias
            if let Some(query) = aq_ctx.query() {
                let subquery = convert_query(&query)?;
                let alias = aq_ctx.tableAlias().and_then(|alias| {
                    if let Some(strict_id) = alias.strictIdentifier() {
                        Some(strict_id.get_text())
                    } else {
                        None
                    }
                });
                
                Ok(TableRef {
                    source: TableSource::Subquery(Box::new(subquery)),
                    alias,
                    lateral_views: Vec::new(),
                    pivot: None,
                    unpivot: None,
                    tablesample: None,
                })
            } else {
                Err(FormatError::new("AliasedQuery missing query".to_string()))
            }
        }
        RelationPrimaryContextAll::AliasedRelationContext(ar_ctx) => {
            // Parenthesized relation with alias
            if let Some(relation) = ar_ctx.relation() {
                convert_relation(&relation)
            } else {
                Err(FormatError::new("AliasedRelation missing relation".to_string()))
            }
        }
        _ => {
            // Fallback for other relation types
            Err(FormatError::new(format!(
                "Unsupported relation primary type: {}",
                ctx.get_text()
            )))
        }
    }
}

// ============================================================================
// WHERE Clause Conversion
// ============================================================================

/// Convert WhereClauseContext
fn convert_where_clause(ctx: &WhereClauseContext) -> Result<WhereClause, FormatError> {
    if let Some(bool_expr) = ctx.booleanExpression() {
        let expr = convert_boolean_expression(&bool_expr)?;
        
        // Convert to conditions list
        let conditions = expression_to_conditions(expr);
        
        Ok(WhereClause { conditions })
    } else {
        Err(FormatError::new("WHERE clause missing expression".to_string()))
    }
}

/// Convert an expression tree to a flat list of conditions with logical operators
fn expression_to_conditions(expr: Expression) -> Vec<Condition> {
    match expr {
        Expression::BinaryOp { left, op, right } if op == "AND" || op == "OR" => {
            let mut conditions = expression_to_conditions(*left);
            let mut right_conditions = expression_to_conditions(*right);
            
            // Set the logical op on the last condition of the left side
            if let Some(last) = conditions.last_mut() {
                last.logical_op = Some(if op == "AND" { LogicalOp::And } else { LogicalOp::Or });
            }
            
            conditions.append(&mut right_conditions);
            conditions
        }
        _ => {
            vec![Condition {
                expr,
                logical_op: None,
                trailing_comment: None,
            }]
        }
    }
}

// ============================================================================
// GROUP BY / HAVING Clause Conversion
// ============================================================================

/// Convert AggregationClauseContext (GROUP BY)
fn convert_aggregation_clause(ctx: &AggregationClauseContext) -> Result<GroupByClause, FormatError> {
    let mut items = Vec::new();
    
    // groupByClause contains groupingExpressions
    for group_expr in ctx.groupByClause_all() {
        for expr in group_expr.expression_all() {
            items.push(convert_expression(&expr)?);
        }
    }
    
    // Also handle direct expression list (older grammar versions)
    for expr in ctx.expression_all() {
        items.push(convert_expression(&expr)?);
    }
    
    Ok(GroupByClause { items })
}

/// Convert HavingClauseContext
fn convert_having_clause(ctx: &HavingClauseContext) -> Result<HavingClause, FormatError> {
    if let Some(bool_expr) = ctx.booleanExpression() {
        let expr = convert_boolean_expression(&bool_expr)?;
        let conditions = expression_to_conditions(expr);
        Ok(HavingClause { conditions })
    } else {
        Err(FormatError::new("HAVING clause missing expression".to_string()))
    }
}

// ============================================================================
// Query Organization (ORDER BY, LIMIT, etc.)
// ============================================================================

/// Apply queryOrganization to a statement (ORDER BY, LIMIT, etc.)
fn apply_query_organization(
    stmt: &mut Statement,
    ctx: &QueryOrganizationContext,
) -> Result<(), FormatError> {
    if let Statement::Select(ref mut query) = stmt {
        // ORDER BY
        if !ctx.sortItem_all().is_empty() {
            let mut items = Vec::new();
            for sort_item in ctx.sortItem_all() {
                if let Some(expr) = sort_item.expression() {
                    let direction = if sort_item.DESC().is_some() {
                        Some(OrderDirection::Desc)
                    } else if sort_item.ASC().is_some() {
                        Some(OrderDirection::Asc)
                    } else {
                        None
                    };
                    
                    items.push(OrderByItem {
                        expr: convert_expression(&expr)?,
                        direction,
                    });
                }
            }
            if !items.is_empty() {
                query.order_by = Some(OrderByClause { items });
            }
        }
        
        // CLUSTER BY (Spark-specific)
        for cluster_by in ctx.clusterByClause_all() {
            let mut items = Vec::new();
            for expr in cluster_by.expression_all() {
                items.push(convert_expression(&expr)?);
            }
            if !items.is_empty() {
                query.cluster_by = Some(ClusterByClause { items });
            }
        }
        
        // DISTRIBUTE BY (Spark-specific)
        for dist_by in ctx.distributeByClause_all() {
            let mut items = Vec::new();
            for expr in dist_by.expression_all() {
                items.push(convert_expression(&expr)?);
            }
            if !items.is_empty() {
                query.distribute_by = Some(DistributeByClause { items });
            }
        }
        
        // SORT BY (Spark-specific)
        for sort_by in ctx.sortByClause_all() {
            let mut items = Vec::new();
            for sort_item in sort_by.sortItem_all() {
                if let Some(expr) = sort_item.expression() {
                    let direction = if sort_item.DESC().is_some() {
                        Some(OrderDirection::Desc)
                    } else if sort_item.ASC().is_some() {
                        Some(OrderDirection::Asc)
                    } else {
                        None
                    };
                    items.push(OrderByItem {
                        expr: convert_expression(&expr)?,
                        direction,
                    });
                }
            }
            if !items.is_empty() {
                query.sort_by = Some(SortByClause { items });
            }
        }
        
        // LIMIT
        if let Some(limit) = ctx.limit.as_ref() {
            // limitRowCount can be an expression
            query.limit = Some(LimitClause {
                count: limit.get_text(),
            });
        }
    }
    
    Ok(())
}

// ============================================================================
// CTE (WITH clause) Conversion
// ============================================================================

/// Apply CTEs to a statement
fn apply_ctes(stmt: &mut Statement, ctx: &CtesContext) -> Result<(), FormatError> {
    if let Statement::Select(ref mut query) = stmt {
        let mut ctes = Vec::new();
        
        for cte in ctx.namedQuery_all() {
            let name = if let Some(name_ctx) = cte.name.as_ref() {
                name_ctx.get_text()
            } else {
                continue;
            };
            
            if let Some(query_ctx) = cte.query() {
                let cte_query = convert_query(&query_ctx)?;
                ctes.push(Cte {
                    name,
                    query: Box::new(cte_query),
                });
            }
        }
        
        if !ctes.is_empty() {
            query.with_clause = Some(WithClause { ctes });
        }
    }
    
    Ok(())
}

// ============================================================================
// Set Operations (UNION, EXCEPT, etc.)
// ============================================================================

/// Convert a set operation (UNION, EXCEPT, INTERSECT, MINUS)
fn convert_set_operation(ctx: &SetOperationContext) -> Result<Statement, FormatError> {
    // Get left operand
    let left = ctx.left.as_ref().ok_or_else(|| {
        FormatError::new("Set operation missing left operand".to_string())
    })?;
    
    // Get right operand
    let right = ctx.right.as_ref().ok_or_else(|| {
        FormatError::new("Set operation missing right operand".to_string())
    })?;
    
    // Determine operator
    let is_all = ctx.setQuantifier()
        .map(|sq| sq.ALL().is_some())
        .unwrap_or(false);
    
    let op = if ctx.UNION().is_some() {
        if is_all { SetOperator::UnionAll } else { SetOperator::Union }
    } else if ctx.EXCEPT().is_some() || ctx.SETMINUS().is_some() {
        // EXCEPT and MINUS are the same
        return Err(FormatError::new(
            "EXCEPT/MINUS not yet supported in AST converter".to_string()
        ));
    } else if ctx.INTERSECT().is_some() {
        return Err(FormatError::new(
            "INTERSECT not yet supported in AST converter".to_string()
        ));
    } else {
        return Err(FormatError::new(
            "Unknown set operator".to_string()
        ));
    };
    
    // Convert operands
    let left_stmt = convert_query_term(left)?;
    let right_stmt = convert_query_term(right)?;
    
    // Extract SelectQuery from left
    let left_query = match left_stmt {
        Statement::Select(sq) => sq,
        _ => return Err(FormatError::new(
            "Left side of UNION must be a SELECT".to_string()
        )),
    };
    
    Ok(Statement::SetOperation(SetOperation {
        left: Box::new(left_query),
        op,
        right: Box::new(right_stmt),
    }))
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::antlr_parser;
    
    fn parse_and_convert(sql: &str) -> Result<Statement, FormatError> {
        let parse_result = antlr_parser::parse(sql)?;
        convert(&parse_result.tree)
    }
    
    #[test]
    fn test_simple_select() {
        let result = parse_and_convert("SELECT a, b, c");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(!query.select_list.is_empty());
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_select_with_from() {
        let result = parse_and_convert("SELECT a, b FROM table1");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(query.from.is_some());
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_select_with_where() {
        let result = parse_and_convert("SELECT a FROM t WHERE x = 1");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(query.where_clause.is_some());
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_select_distinct() {
        let result = parse_and_convert("SELECT DISTINCT a, b FROM t");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(query.distinct);
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_select_with_group_by() {
        let result = parse_and_convert("SELECT a, COUNT(*) FROM t GROUP BY a");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(query.group_by.is_some());
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_select_with_order_by() {
        let result = parse_and_convert("SELECT a FROM t ORDER BY a DESC");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(query.order_by.is_some());
            let order_by = query.order_by.unwrap();
            assert_eq!(order_by.items.len(), 1);
            assert_eq!(order_by.items[0].direction, Some(OrderDirection::Desc));
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_select_with_limit() {
        let result = parse_and_convert("SELECT a FROM t LIMIT 10");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::Select(query) = result.unwrap() {
            assert!(query.limit.is_some());
            assert_eq!(query.limit.unwrap().count, "10");
        } else {
            panic!("Expected SELECT statement");
        }
    }
    
    #[test]
    fn test_union() {
        let result = parse_and_convert("SELECT a FROM t1 UNION SELECT b FROM t2");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::SetOperation(set_op) = result.unwrap() {
            assert!(matches!(set_op.op, SetOperator::Union));
        } else {
            panic!("Expected UNION statement");
        }
    }
    
    #[test]
    fn test_union_all() {
        let result = parse_and_convert("SELECT a FROM t1 UNION ALL SELECT b FROM t2");
        assert!(result.is_ok(), "Failed to convert: {:?}", result.err());
        
        if let Statement::SetOperation(set_op) = result.unwrap() {
            assert!(matches!(set_op.op, SetOperator::UnionAll));
        } else {
            panic!("Expected UNION ALL statement");
        }
    }
}
// 3. Push/pop from stacks as needed for nested structures
// 4. NEVER use `_ => {}` catch-all that would drop tokens

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ast_converter_not_implemented() {
        let result = convert(&());
        assert!(result.is_err());
    }

    #[test]
    fn test_ast_builder_empty() {
        let builder = AstBuilder::new();
        let result = builder.finish();
        assert!(result.is_err());
    }
}
